

# 总结
1. scala-2.10之后，将actor整合到akka包.从Scala2.10起，Akka 作为Scala 开发包的一部分发布，因此无需另外添加引用


## 资料汇总
- akka官方doc
  - 在线:
  [akka官方doc](http://akka.io/docs/)
  - 本地:
    /home/kigo/桌面/HZ/文档资料/Scala/officer/document/a-Akka/AkkaScala Documentation-2.4.pdf

## 术语
- actor
  >每个Actor有自己的消息队列，可以接受消息，然后对消息进行处理，这里通过定义receive方法来实现的.
  - 注意Actor的实例是不能直接使用new 来创建的。而是使用系统的actorOf方法来创建
- ActorSystem
  >Akka系统（注意Akka系统消耗比较大，一个应用较好只构建一个）  
  参考: https://doc.akka.io/docs/akka/snapshot/general/actor-systems.html

## 要点总结

### 同步异步发送消息
! 发送异步消息，没有返回值。  
!? 发送同步消息，等待返回值。  
!! 发送异步消息，返回值是 Future[Any]。  

### Actor层次结构
- 层次结构
>和商业组织（比如公司）类型，Actors之间也具有层次结构，一个Actor可以负责程序的某个功能，可以需要把分配给它的任务分成更小的便于管理的小任务。因此一个actor可以创建多个子Actor来完成这些小任务，并负责管理它们。每个Actor有且只有一个管理者（supervisor)。
Actor系统的一个精髓是可以把一个复杂的任务分解成小的可以处理的问题。这样做的好处是不仅仅任务本身结构清晰，而且用来处理它的Actor的消息也可以很好的进行分析，如果某个Actor不能处理某些情况，它可以给它的管理员发送失败消息，请求帮助。这种逐级上报的结构支持在适当的层次来处理错误。
我们在定义一个Actor时较好符合下面一些规则：

Actors应当是一个好同事，高效的完成自身的问题而不给别的Actor造成不必要的麻烦和不过分占用资源。使用编程的术语来说，就是使用事件处理的方式来处理事件并返回结果。Actor不该阻塞某些外部实体（比如一个锁，网络端口）
不要在Actor之间传递可以变化的数据，因此优先使用状态不变的消息。
Actor可以保存某些状态，并定义了一些功能，这意味着不同时传递数据和处理这些数据的行为。
最上层的Actor应该是你处理错误的最核心的那一层，因此不要过多的创建最上层的Actor，优先考虑纯等级结构。
- 仔细管理阻塞操作
如果某些可能造成阻塞的操作无法避免，比如在需要等待某些外部条件发生时使线程进入睡眠状态（比如网络操作时），在处理这些情况下，你可能非常想使用Future来封装这些阻塞操作，但这种方法过于简单化，你可能很快发现瓶颈或者内存不足等现象。
这里给出一个可以用来解决这个问题的解决方案的不完全列表：

  - 在一个actor中完成这个阻塞操作，并且确保使用一个线程池专门来完成这项操作。
  - 使用一个Future来完成这个阻塞操作，给出可以同时处理这个操作的数目的上界。
  - 使用一个Future来完成这个阻塞操作，并使用一个定义了上界的线程池。
  - 专门定义一个线程来管理一组可能被阻塞的资源，然后在事件发生时由它给Actor分发消息。
